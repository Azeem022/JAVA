==================================What is a method in Java programming?
 Java Method is a collection of statements that perform some specific task and return the result to the caller. 


===================What are parts of method in Java?
 The 5 methods parts in Java are mentioned below: 


 Modifiers 
 Return Type 
 Method Name 
 Parameters 
 Method Body 
=======================================Is java support method overloading?
Yes, Java supports Method overloading but changing there parameter and return type.
=======================================What are the types of methods in Java?
There are mainly 2 types of methods in Java


Instance methods
Static methods

=======================================What is the main difference between Constructor and Method in Java?
A method is a block of code which perform certain tasks, but constructor is a special type of method. which used to initialize objects when they are created and have a same name as a class.

====================================Calling the Static Methods
Static methods belong to the class and can be called without creating an object.
// Java Program to call Static Methods
import java.io.*;

class test {
  
    // Static method
    static void hello()
    {
        System.out.println("Hello");
    }
}

class GFG {

    public static void main(String[] args) {
      
        // calling the Method 1
        // Accessing method
        test.hello();
    }
}
================================Static Method vs Instance Method in Java
Last Updated : 02 Jan, 2025
In Java, methods are mainly divided into two parts based on how they are associated with a class, which are the static method and the Instance method. The main difference between static and instance methods is:

Static method: This method belongs to the class and can be called without creating an object.
Memory Allocation of Static Methods: Static methods belong to the class, not its objects, and they are stored in the Permanent Generation space of the heap. Their local variables and arguments are stored in the stack. They can be called without creating an instance of the class, using ClassName.methodName(args).

Important Points:

Static methods are shared among all objects of the class.
They cannot be overridden as they use static binding at compile time.
If both superclass and subclass have static methods with the same name, it is called Method Hiding, where the subclass method hides the superclass method.


Instance method: This method belongs to an object and requires an object to be called.
Memory Allocation of Instance Method: Instance methods are stored in the Permanent Generation space of the heap (till Java 7, replaced by Metaspace from Java 8 for better efficiency). Their parameters, local variables, and return values are allocated on the stack. They can be called within their class or from other classes, based on their access modifiers.

Important Points:

Instance methods belong to the object, not the class, and require an object to be called.
They are stored in one memory location and identify their object through the this pointer.
They can be overridden as they use dynamic binding at runtime.

=============================When to use static methods? 
Use static methods when:
The method does not depend on the state of an object.
Code can be shared across all objects of a class (e.g., utility methods).

===========================What are access modifiers in Java?
Access modifiers in Java are the keywords that are used for controlling the use of the methods, constructors, fields, and methods in a class.

What is the default access modifier in Java?
The default access modifier allows access within the same package only.

Can a private method be accessed outside its class?
No, a private method is only accessible within its own class.


What does the protected access modifier do?
The protected modifier allows access within the same package and by subclasses.


Can public variables be accessed from any class?
Yes, public variables are accessible from any class, regardless of the package.

=================================How can we initialize an array in Java?
Arrays in Java can be initialized in several ways:


Static Initialization: int[] arr = {1, 2, 3};
Dynamic Initialization: int[] arr = new int[5];
Initialization with a loop: for (int i = 0; i < arr.length; i++) { arr[i] = i + 1; }
@
==============================Can we change the size of an array after it is created in Java?
No, the size of an array in Java cannot be changed once it is initialized. Arrays are fixed-size. To work with a dynamically sized collection, consider using classes from the java.util package, such as ArrayList.

=========================What is the direct superclass of an array in Java?
The direct superclass of an array in Java is Object . Arrays inherit methods from the Object class, including toString(), equals(), and hashCode(). 


=============================taking user input using for loop in java 
package Basics2;
import java.io.PrintStream;
import java.util.Scanner;
public class UserInput {
    public static void main(String[] args) {
        Scanner object = new Scanner(System.in);
        System.out.println("Enter the value of row :");
        int row = object.nextInt();
        System.out.println("Enter the value of column :");
        int column = object.nextInt();
        int [][] array = new int[row][column];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                array[i][j] = object.nextInt();
            }
        }
        System.out.println("You Entered 2D array is :");
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                System.out.print(array[i][j]+" ");
            }
            System.out.println();
        }
    }
}


================================ METHOD ==================================
üöÄ LEVEL 0: Basic Method With No Parameters and No Return
java
Copy
Edit
public class HelloWorld {
    public void greet() {
        System.out.println("Hello, World!");
    }

    public static void main(String[] args) {
        HelloWorld obj = new HelloWorld();
        obj.greet();  // Output: Hello, World!
    }
}



üöÄ LEVEL 1: Method With Parameters (Inputs) and void Return
java
Copy
Edit
public class Printer {
    public void printName(String name) {
        System.out.println("Your name is: " + name);
    }

    public static void main(String[] args) {
        Printer p = new Printer();
        p.printName("Rahul");  // Output: Your name is: Rahul
    }
}


üöÄ LEVEL 2: Method With Return Value
java
Copy
Edit
public class Adder {
    public int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        Adder obj = new Adder();
        int sum = obj.add(5, 7);
        System.out.println("Sum is: " + sum);  // Output: Sum is: 12
    }
}



üöÄ LEVEL 3: Multiple Parameters, Multiple Methods
java
Copy
Edit
public class MathOperations {

    public int subtract(int a, int b) {
        return a - b;
    }

    public double divide(double x, double y) {
        return x / y;
    }

    public static void main(String[] args) {
        MathOperations m = new MathOperations();
        System.out.println("Subtract: " + m.subtract(10, 4));
        System.out.println("Divide: " + m.divide(20, 4));
    }
}



üöÄ LEVEL 6: Method Overloading
java
Copy
Edit
public class OverloadExample {

    public int multiply(int a, int b) {
        return a * b;
    }

    public double multiply(double a, double b) {
        return a * b;
    }

    public static void main(String[] args) {
        OverloadExample obj = new OverloadExample();
        System.out.println(obj.multiply(2, 3));      // 6
        System.out.println(obj.multiply(2.5, 4.0));  // 10.0
    }
}



üîê What is Encapsulation?
Encapsulation means wrapping data (variables) and code (methods) into a single unit, like a capsule üíä.
In Java, this is achieved by:

Making fields private

Giving public getter & setter methods to access/update them

üî∏ Think of it like:
"Mobile ka internal system user se hidden hota hai, sirf buttons diye jaate hain control ke liye."

‚úÖ Example of Encapsulation
java
Copy
Edit
public class Account {
    // Step 1: Make fields private
    private String name;
    private double balance;

    // Step 2: Create public getters and setters
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setBalance(double amount) {
        if (amount >= 0) {
            this.balance = amount;
        }
    }

    public double getBalance() {
        return balance;
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Account acc = new Account();

        acc.setName("Ravi");
        acc.setBalance(5000);

        System.out.println(acc.getName());     // Ravi
        System.out.println(acc.getBalance());  // 5000
    }
}
‚úÖ Encapsulation protects data and gives you controlled access.




üîπ 1. public: Accessible from anywhere
java
Copy
Edit
public class Car {
    public String brand = "Honda";
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Car c = new Car();
        System.out.println(c.brand);  // Accessible anywhere
    }
}
üîπ 2. private: Accessible only inside the same class
java
Copy
Edit
public class Bank {
    private double balance = 1000;

    public double getBalance() {
        return balance;
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Bank b = new Bank();
        // System.out.println(b.balance); ‚ùå Error: private
        System.out.println(b.getBalance()); ‚úÖ OK
    }
}
üîπ 3. protected: Accessible in same package + subclass (even if in different package)
java
Copy
Edit
class Animal {
    protected String type = "Mammal";
}

class Dog extends Animal {
    public void printType() {
        System.out.println(type);  // ‚úÖ Accessible
    }
}
üîπ 4. Default (no modifier): Accessible only within the same package
java
Copy
Edit
class Phone {
    String model = "iPhone";  // Default access
}
java
Copy
Edit
// Accessible only if in same package
public class Main {
    public static void main(String[] args) {
        Phone p = new Phone();
        System.out.println(p.model);  // ‚úÖ Only if in same package
    }
}



üß† What are Getters and Setters?
üîπ Getters:
Ye methods field ki value read karne ke liye hote hain.

üîπ Setters:
Ye methods field ki value set/update karne ke liye hote hain.

‚ùó Generally fields private hote hain (Encapsulation), aur unke access ke liye public getter/setter diye jaate hain.

‚úÖ Why Use Them Instead of Direct Access?
java
Copy
Edit
// ‚ùå NOT Recommended
public class Student {
    public String name;  // Direct access ‚Äì bad practice
}
Isse data unsafe ho jata hai, koi bhi change kar sakta hai.

Instead, use private fields + get/set methods ‚Üí ‚úÖ Safe

‚úÖ Example: Getters and Setters
java
Copy
Edit
public class Student {
    private String name;
    private int age;

    // Getter for name
    public String getName() {
        return name;
    }

    // Setter for name
    public void setName(String name) {
        this.name = name;
    }

    // Getter for age
    public int getAge() {
        return age;
    }

    // Setter for age
    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        }
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Student s = new Student();

        s.setName("Ravi");
        s.setAge(20);

        System.out.println("Name: " + s.getName());
        System.out.println("Age: " + s.getAge());
    }
}



üîπ 1. Validation in Setter
java
Copy
Edit
public void setMarks(int marks) {
    if (marks >= 0 && marks <= 100) {
        this.marks = marks;
    } else {
        System.out.println("Invalid marks!");
    }
}
üîπ 2. Read-only Field (Only Getter)
java
Copy
Edit
private final int id = 101;

public int getId() {
    return id;  // No setter ‚Üí read-only
}
üîπ 3. Write-only Field (Only Setter)
java
Copy
Edit
private String password;

public void setPassword(String password) {
    this.password = password;
}




üß† What is Inheritance?
Inheritance means:
üîÑ "Ek class (child) dusri class (parent) ke properties and methods ko inherit kar sakti hai".

In short:
üî∏ Code reuse
üî∏ Hierarchy (parent-child relationship)
üî∏ Follows "is-a" relationship

‚úÖ Syntax: extends Keyword
java
Copy
Edit
class Parent {
    // fields and methods
}

class Child extends Parent {
    // inherits everything from Parent
}
üìå extends ka matlab hota hai:
"Ye class us parent class ke saare methods aur variables inherit karegi."

üßæ Example: Basic Inheritance
java
Copy
Edit
// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Child class
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks.");
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();   // Inherited from Animal
        d.bark();  // Defined in Dog
    }
}




‚úÖ Types of Inheritance in Java
Java supports Single, Multilevel, and Hierarchical Inheritance
‚ùå Java does not support Multiple Inheritance with classes (to avoid ambiguity), but you can achieve it with interfaces.

üî∏ 1. Single Inheritance
java
Copy
Edit
class A {
    void showA() { System.out.println("Class A"); }
}

class B extends A {
    void showB() { System.out.println("Class B"); }
}
üî∏ 2. Multilevel Inheritance
java
Copy
Edit
class A {
    void a() { System.out.println("A"); }
}

class B extends A {
    void b() { System.out.println("B"); }
}

class C extends B {
    void c() { System.out.println("C"); }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        C obj = new C();
        obj.a();  // from A
        obj.b();  // from B
        obj.c();  // from C
    }
}
üî∏ 3. Hierarchical Inheritance
java
Copy
Edit
class Animal {
    void eat() { System.out.println("eating..."); }
}

class Dog extends Animal {
    void bark() { System.out.println("barking..."); }
}

class Cat extends Animal {
    void meow() { System.out.println("meowing..."); }
}
‚ùå Why Java Doesn‚Äôt Support Multiple Inheritance with Classes
java
Copy
Edit
class A {
    void show() { System.out.println("A"); }
}

class B {
    void show() { System.out.println("B"); }
}

// class C extends A, B ‚ùå Not allowed ‚Äì ambiguity
‚úîÔ∏è Java solves this using interfaces, not classes.

üë®‚Äçüè´ Why Java Doesn‚Äôt Support Multiple Inheritance (with classes)
üî¥ Because it causes confusion called the "Diamond Problem"
üü° Let‚Äôs Break It Down:
‚úÖ First: What is Multiple Inheritance?
When a class inherits from more than one class, it‚Äôs called multiple inheritance.

üîß Example in C++ (which allows multiple inheritance):
cpp
Copy
Edit
class A {
    void show();
};

class B {
    void show();
};

class C : public A, public B {
    // Inherits from both A and B
};
‚ùìProblem: What if both A and B have the same method?
cpp
Copy
Edit
class A {
    void show() { cout << "A"; }
};

class B {
    void show() { cout << "B"; }
};

class C : public A, public B {
    // Which 'show()' will C use? A or B?
};
This creates ambiguity/confusion. This is called the diamond problem.


üß† What is Inheritance?
Inheritance means:
üîÑ "Ek class (child) dusri class (parent) ke properties and methods ko inherit kar sakti hai".

üßæ Example: Basic Inheritance
java
Copy
Edit
// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Child class
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks.");
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();   // Inherited from Animal
        d.bark();  // Defined in Dog
    }
}



üîÑ What is Method Overriding?
Method Overriding means:
üîÅ "Child class apne parent class ke method ko dubara define karta hai (same name, same parameters)"

‚úÖ Overriding allows custom behavior in the child class.

üìå When Do We Use It?
Jab child class parent ka method inherit karta hai

But chahta hai ki apna version implement kare

‚úÖ Rules of Method Overriding
Method name must be same

Parameters must be same (signature)

Must be inherited from parent class

Cannot override private, static, or final methods

Access modifier should be same or more visible

üîß Syntax Example:
java
Copy
Edit
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();  // Polymorphism
        a.sound();  // Output: Dog barks
    }
}


 Explanation:
sound() method is defined in parent class Animal

Dog overrides that method to give custom behavior

‚úÖ We use @Override annotation for clarity (optional, but recommended)



üîÄ Super Keyword with Overriding
Use super.method() to call parent method inside overridden method.

java
Copy
Edit
class Parent {
    void greet() {
        System.out.println("Hello from Parent");
    }
}

class Child extends Parent {
    @Override
    void greet() {
        super.greet();  // calls parent version
        System.out.println("Hello from Child");
    }
}




‚úÖ Advanced Example: Polymorphism with Overriding
java
Copy
Edit
class Shape {
    void draw() {
        System.out.println("Drawing shape");
    }
}

class Circle extends Shape {
    void draw() {
        System.out.println("Drawing circle");
    }
}

class Square extends Shape {
    void draw() {
        System.out.println("Drawing square");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape s;

        s = new Circle();
        s.draw(); // Drawing circle

        s = new Square();
        s.draw(); // Drawing square
    }
}



üî† What is super keyword?
Java me super ka use child class se parent class ke members (variables, methods, constructor) ko refer karne ke liye hota hai.

üîπ Jab child aur parent class me same naam ke methods ya variables hote hain, tab super se parent version ko call kar sakte ho.

‚úÖ Uses of super keyword:
Use Case	Example
1Ô∏è‚É£ Call parent class method	super.methodName()
2Ô∏è‚É£ Access parent class variable	super.variableName
3Ô∏è‚É£ Call parent constructor	super() (must be 1st line in constructor)



‚úÖ 1. super.method() ‚Äì Call parent method
java
Copy
Edit
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void sound() {
        super.sound();  // üîπ Call parent method
        System.out.println("Dog barks");
    }
}
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
    }
}
Output:
Animal makes sound
Dog barks


‚úÖ 2. super.variable ‚Äì Access parent variable

class Parent {
    int x = 100;
}

class Child extends Parent {
    int x = 200;

    void show() {
        System.out.println("Child x: " + x);         // 200
        System.out.println("Parent x: " + super.x);  // 100
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Child c = new Child();
        c.show();
    }
}

‚úÖ 3. super() ‚Äì Call parent constructor
java
Copy
Edit
class Parent {
    Parent() {
        System.out.println("Parent constructor");
    }
}

class Child extends Parent {
    Child() {
        super(); // üîπ Call to parent constructor
        System.out.println("Child constructor");
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Child c = new Child();
    }
}
üîç Output:
kotlin
Copy
Edit
Parent constructor  
Child constructor

‚úÖ super() always first line in child constructor.
Agar na likho, Java automatically call karta hai super() (default constructor).




üî∂ What is Polymorphism?
Polymorphism means "many forms". In Java, it allows objects to take on many forms, specifically:

Compile-Time Polymorphism (Method Overloading)

Run-Time Polymorphism (Method Overriding)



‚úÖ What is Method Overloading?
When multiple methods in the same class have the same name but different parameters (type or number), it's called method overloading.

üìå Example:
java
Copy
Edit
public class Calculator {
    // Adding two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Adding three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Adding two doubles
    public double add(double a, double b) {
        return a + b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(2, 3));           // 5
        System.out.println(calc.add(2, 3, 4));        // 9
        System.out.println(calc.add(2.5, 3.5));       // 6.0
    }
}
üî∏ Part 2: Run-Time Polymorphism (Method Overriding)
‚úÖ What is Method Overriding?
When a subclass provides its own implementation of a method defined in its superclass, it's called method overriding. This happens at runtime.

üß† Key Conditions:
Method must have same name, return type, and parameters.

The class must use inheritance (extends).

Use @Override annotation (optional but recommended).

üìå Example:
java
Copy
Edit
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class TestPolymorphism {
    public static void main(String[] args) {
        Animal a;          // reference of superclass

        a = new Dog();     // Dog object
        a.sound();         // Dog barks

        a = new Cat();     // Cat object
        a.sound();         // Cat meows
    }
}
üîç Output:
nginx
Copy
Edit
Dog barks
Cat meows
üî∏ Part 3: Polymorphism with Interfaces
‚úÖ Interface Polymorphism
Interfaces support polymorphism because a class can be referred to by its interface type.

üìå Example:
java
Copy
Edit
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Rectangle implements Shape {
    public void draw() {
        System.out.println("Drawing Rectangle");
    }
}

public class InterfacePolymorphism {
    public static void main(String[] args) {
        Shape s;

        s = new Circle();
        s.draw();  // Drawing Circle

        s = new Rectangle();
        s.draw();  // Drawing Rectangle
    }
}
üî∏ Part 4: Advanced Polymorphism ‚Äì Real-World Example
üßæ Example: Payment System
java
Copy
Edit
abstract class Payment {
    abstract void pay(double amount);
}

class CreditCard extends Payment {
    void pay(double amount) {
        System.out.println("Paid $" + amount + " using Credit Card.");
    }
}

class PayPal extends Payment {
    void pay(double amount) {
        System.out.println("Paid $" + amount + " using PayPal.");
    }
}

class Cash extends Payment {
    void pay(double amount) {
        System.out.println("Paid $" + amount + " in Cash.");
    }
}

public class PaymentProcessor {
    public static void processPayment(Payment p, double amount) {
        p.pay(amount); // Polymorphic call
    }

    public static void main(String[] args) {
        processPayment(new CreditCard(), 100.0);
        processPayment(new PayPal(), 250.0);
        processPayment(new Cash(), 50.0);
    }
}
üî∏ Part 5: Polymorphism in Collections (Advanced Concept)
java
Copy
Edit
import java.util.ArrayList;

abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("Meow");
    }
}

public class Zoo {
    public static void main(String[] args) {
        ArrayList<Animal> animals = new ArrayList<>();
        animals.add(new Dog());
        animals.add(new Cat());

        for (Animal a : animals) {
            a.makeSound();  // Dynamic method dispatch
        }
    }
}




üî∂ What is Abstraction?
Abstraction is one of the four pillars of Object-Oriented Programming (OOP), and it means hiding the internal implementation and showing only the necessary details to the user.

üì¶ Think of abstraction like using a TV remote:
You press buttons to change channels (interface), but you don't know how the circuit board inside works (implementation).

üî∏ Why Use Abstraction?
To simplify complexity.

To hide implementation details.

To provide a blueprint for subclasses.

To enforce rules and contracts using abstract classes or interfaces.

üî∏ How Abstraction is Achieved in Java
Java achieves abstraction in two ways:

Abstract Classes (Partial Abstraction)

Interfaces (Full Abstraction, before Java 8)

üîπ 1. Abstract Classes
‚úÖ Definition:
Declared using the abstract keyword.

Can have abstract (no body) and non-abstract (implemented) methods.

Cannot be instantiated directly.

üìå Basic Example:
java
Copy
Edit
abstract class Animal {
    abstract void sound();  // abstract method

    void sleep() {          // concrete method
        System.out.println("Animal is sleeping...");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class TestAbstraction {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.sound();  // Dog barks
        a.sleep();  // Animal is sleeping...
    }
}
üîê Rules of Abstract Class
If a class has at least one abstract method, it must be declared abstract.

Subclasses must override all abstract methods, or they themselves become abstract.

 2. Interfaces
‚úÖ Definition:
An interface is a contract for classes to follow.

Can only have abstract methods (until Java 7), and default/static methods (Java 8+).

A class implements an interface.

üìå Example:
java
Copy
Edit
interface Shape {
    void draw();  // abstract method
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Square implements Shape {
    public void draw() {
        System.out.println("Drawing Square");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        Shape s = new Circle();
        s.draw();  // Drawing Circle

        s = new Square();
        s.draw();  // Drawing Square
    }
}




üî∂ What Are Static Members?
In Java, static members belong to the class rather than to instances (objects) of the class.

You can declare:

static variables (also called class variables)

static methods

static blocks




üî∏ 1. Static Variables (Class Variables)
A static variable is shared among all instances of a class. There's only one copy in memory.

üìå Example:
java
Copy
Edit
class Counter {
    static int count = 0;  // shared among all objects

    Counter() {
        count++;  // increments shared variable
        System.out.println("Count: " + count);
    }

    public static void main(String[] args) {
        new Counter();  // Count: 1
        new Counter();  // Count: 2
        new Counter();  // Count: 3
    }
}
üß† Notice: All objects update the same count variable.

üî∏ 2. Static Methods
Static methods belong to the class, not the object. You can call them without creating an instance.

‚úÖ Key Rules:
Can only access static data directly.

Cannot use this or super.

Often used for utility or helper methods.

üìå Example:
java
Copy
Edit
class MathUtils {
    static int square(int x) {
        return x * x;
    }

    public static void main(String[] args) {
        System.out.println(MathUtils.square(5));  // 25
    }
}
üî∏ 3. Static Block (Static Initializer)
Static blocks run once, when the class is first loaded into memory.

üìå Example:
java
Copy
Edit
class Demo {
    static {
        System.out.println("Static block executed.");
    }

    public static void main(String[] args) {
        System.out.println("Main method executed.");
    }
}
üîç Output:
scss
Copy
Edit
Static block executed.
Main method executed.
üß† Use static blocks to initialize static variables or perform setup logic before the main method.




üî∂ What is a Package?
A package in Java is a namespace that groups related classes and interfaces together.

Think of it like folders on your computer:

üìÅ java.util ‚Üí for utility classes

üìÅ java.io ‚Üí for input/output classes

üî∏ Why Use Packages?
‚úÖ Avoid name conflicts
‚úÖ Organize code better
‚úÖ Control access (with access modifiers)
‚úÖ Reusability and modularization

üî∏ Types of Packages
1. Built-in Packages ‚Äì Provided by Java
Examples:

java
Copy
Edit
import java.util.Scanner;
import java.io.File;
import java.lang.Math;  // automatically imported
2. User-defined Packages ‚Äì Created by you
üîπ How to Create a User-defined Package
‚úÖ Step-by-step:
1. Create a package
java
Copy
Edit
// File: MyPackage/Message.java
package MyPackage;

public class Message {
    public void show() {
        System.out.println("Hello from MyPackage!");
    }
}
2. Use the package
java
Copy
Edit
// File: Main.java
import MyPackage.Message;

public class Main {
    public static void main(String[] args) {
        Message m = new Message();
        m.show();
    }
}

import java.util.Scanner;          // Import a single class
import java.util.*;                // Import all classes in java.util
import static java.lang.Math.*;    // Static import (for static members)



üî∂ What is Exception Handling?
An exception is an unexpected event that disrupts the normal flow of a program.

Exception Handling is Java‚Äôs mechanism to:

Detect errors

Handle them gracefully (without crashing)

Maintain program flow

üî∏ Why Use Exception Handling?
‚úÖ Prevent program from crashing
‚úÖ Separate error-handling logic from main logic
‚úÖ Handle runtime errors (like divide by zero, file not found)

üî∂ Types of Exceptions
Java has two main types:

Type	Description	Example
Checked	Caught at compile time	IOException, SQLException
Unchecked	Caught at runtime	ArithmeticException, NullPointerException

üî∂ Basic Syntax
java
Copy
Edit
try {
    // risky code
} catch (ExceptionType name) {
    // handling code
} finally {
    // optional block; always executes
}
üî∏ üìå Example 1: Handling Divide by Zero
java
Copy
Edit
public class Divide {
    public static void main(String[] args) {
        try {
            int a = 10 / 0; // Risky
        } catch (ArithmeticException e) {
            System.out.println("Cannot divide by zero!");
        }
    }
}
üîç Output:
csharp
Copy
Edit
Cannot divide by zero!
üî∏ üìå Example 2: Multiple Catch Blocks
java
Copy
Edit
public class MultipleCatch {
    public static void main(String[] args) {
        try {
            int[] arr = new int[3];
            arr[5] = 10;  // ArrayIndexOutOfBoundsException
        } catch (ArithmeticException e) {
            System.out.println("Math error.");
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index error.");
        } catch (Exception e) {
            System.out.println("General error.");
        }
    }
}
Always catch specific exceptions first, then general ones.

üî∏ üìå Example 3: The finally Block
java
Copy
Edit
public class FinallyBlock {
    public static void main(String[] args) {
        try {
            System.out.println("Inside try");
        } catch (Exception e) {
            System.out.println("Exception caught");
        } finally {
            System.out.println("This always runs!");
        }
    }
}
finally is used to close resources, like files or database connections.



üî∏ üìå Example 4: throw Keyword
Manually throw an exception.

java
Copy
Edit
public class ThrowExample {
    public static void main(String[] args) {
        int age = 15;
        if (age < 18) {
            throw new ArithmeticException("Not eligible to vote");
        }
    }
}



üî∏ üìå Example 5: throws Keyword
Tell the compiler that a method may throw an exception.

java
Copy
Edit
import java.io.*;

public class ThrowsExample {
    public static void readFile() throws IOException {
        FileReader fr = new FileReader("file.txt");
        fr.read();
    }

    public static void main(String[] args) throws IOException {
        readFile();  // caller is responsible
    }
}

üî∂ What is Java Collections Framework?
The Java Collections Framework (JCF) is a set of classes and interfaces in java.util for storing, retrieving, and manipulating groups of data.

Think of it like Java's built-in toolbox for:

Lists üìã

Sets ‚úÖ

Maps üó∫Ô∏è

Queues ‚è≥

Stacks üìö

1. List ‚Äì Ordered, allows duplicates
Implementations: ArrayList, LinkedList, Vector, Stack

1Ô∏è‚É£ ArrayList ‚Äì Most commonly used list
üîß Internally:
Uses a resizable array

Fast for accessing elements (get(), set())

import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Java");
        list.add("Python");
        list.add("Java"); // duplicates allowed

        System.out.println(list); // [Java, Python, Java]
    }
}


2Ô∏è‚É£ LinkedList ‚Äì Good for insertions/deletions
üîß Internally:
Uses a doubly linked list

Nodes have reference to next and previous

import java.util.*;

public class LinkedListExample {
    public static void main(String[] args) {
        List<String> list = new LinkedList<>();
        list.add("Node1");
        list.add("Node2");
        list.add("Node3");

        System.out.println(list); // [Node1, Node2, Node3]
    }
}

‚úÖ Best Use:
When you need to insert/delete a lot

Use as a queue or deque

3Ô∏è‚É£ Vector ‚Äì Thread-safe ArrayList
üîß Internally:
Like ArrayList but synchronized

import java.util.*;

public class VectorExample {
    public static void main(String[] args) {
        Vector<Integer> vec = new Vector<>();
        vec.add(1);
        vec.add(2);
        vec.add(3);

        System.out.println(vec); // [1, 2, 3]
    }
}


4Ô∏è‚É£ Stack ‚Äì LIFO structure (Last-In, First-Out)
üîß Internally:
Extends Vector

Has LIFO methods: push(), pop(), peek()

import java.util.*;

public class StackExample {
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>();
        stack.push("A");
        stack.push("B");
        stack.push("C");

        System.out.println(stack.pop()); // C
        System.out.println(stack.peek()); // B
    }
}
