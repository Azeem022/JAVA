==================================What is a method in Java programming?
In Java programming, a method is a block of code that performs a specific task and can be called whenever needed.

public class Calculator {
    // method with parameters and return type
    int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int result = calc.add(5, 7); // calling method
        System.out.println("Sum: " + result);
    }
}


===================What are parts of method in Java?
 The 5 methods parts in Java are mentioned below: 


 Modifiers 
 Return Type 
 Method Name 
 Parameters 
 Method Body 
=======================================Is java support method overloading?
Yes, Java supports Method overloading but changing there parameter and return type.
=======================================What are the types of methods in Java?
There are mainly 2 types of methods in Java


Instance methods
Static methods

=======================================What is the main difference between Constructor and Method in Java?
A method is a block of code which perform certain tasks, but constructor is a special type of method. which used to initialize objects when they are created and have a same name as a class.

====================================Calling the Static Methods
Static methods belong to the class and can be called without creating an object.
// Java Program to call Static Methods
import java.io.*;

class test {
  
    // Static method
    static void hello()
    {
        System.out.println("Hello");
    }
}

class GFG {

    public static void main(String[] args) {
      
        // calling the Method 1
        // Accessing method
        test.hello();
    }
}
================================Static Method vs Instance Method in Java
Static method: This method belongs to the class and can be called without creating an object.
Memory Allocation of Static Methods: Static methods belong to the class, not its objects, and they are stored in the Permanent Generation space of the heap. Their local variables and
arguments are stored in the stack. They can be called without creating an instance of the class, using ClassName.methodName(args).

Memory Allocation

Static method

Stored in Method Area (PermGen space in Java 7 and earlier, replaced by Metaspace in Java 8+)

Instance method


Stored in Method Area (PermGen/Metaspace)

Important Points:

Static methods are shared among all objects of the class.
They cannot be overridden as they use static binding at compile time.
If both superclass and subclass have static methods with the same name, it is called Method Hiding, where the subclass method hides the superclass method.


Instance method: This method belongs to an object and requires an object to be called.
Memory Allocation of Instance Method: Instance methods are stored in the Permanent Generation space of the heap (till Java 7, replaced by Metaspace from Java 8 for better efficiency).
Their parameters, local variables, and return values are allocated on the stack. They can be called within their class or from other classes, based on their access modifiers.

Important Points:

Instance methods belong to the object, not the class, and require an object to be called.
They are stored in one memory location and identify their object through the this pointer.
They can be overridden as they use dynamic binding at runtime.

=============================When to use static methods? 
Use static methods when:
The method does not depend on the state of an object.
Code can be shared across all objects of a class (e.g., utility methods).

===========================What are access modifiers in Java?
Access modifiers in Java are the keywords that are used for controlling the use of the methods, constructors, fields, and methods in a class.

What is the default access modifier in Java?
The default access modifier allows access within the same package only.

Can a private method be accessed outside its class?
No, a private method is only accessible within its own class.


What does the protected access modifier do?
The protected modifier allows access within the same package and by subclasses.


Can public variables be accessed from any class?
Yes, public variables are accessible from any class, regardless of the package.

=================================How can we initialize an array in Java?
Arrays in Java can be initialized in several ways:


Static Initialization: int[] arr = {1, 2, 3};
Dynamic Initialization: int[] arr = new int[5];
Initialization with a loop: for (int i = 0; i < arr.length; i++) { arr[i] = i + 1; }
@
==============================Can we change the size of an array after it is created in Java?
No, the size of an array in Java cannot be changed once it is initialized. Arrays are fixed-size. To work with a dynamically sized collection, consider using classes from the java.util package, such as ArrayList.

=========================What is the direct superclass of an array in Java?
The direct superclass of an array in Java is Object . Arrays inherit methods from the Object class, including toString(), equals(), and hashCode(). 


=============================taking user input using for loop in java 
package Basics2;
import java.io.PrintStream;
import java.util.Scanner;
public class UserInput {
    public static void main(String[] args) {
        Scanner object = new Scanner(System.in);
        System.out.println("Enter the value of row :");
        int row = object.nextInt();
        System.out.println("Enter the value of column :");
        int column = object.nextInt();
        int [][] array = new int[row][column];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                array[i][j] = object.nextInt();
            }
        }
        System.out.println("You Entered 2D array is :");
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                System.out.print(array[i][j]+" ");
            }
            System.out.println();
        }
    }
}


================================ METHOD ==================================
🚀 LEVEL 0: Basic Method With No Parameters and No Return
java
Copy
Edit
public class HelloWorld {
    public void greet() {
        System.out.println("Hello, World!");
    }

    public static void main(String[] args) {
        HelloWorld obj = new HelloWorld();
        obj.greet();  // Output: Hello, World!
    }
}



🚀 LEVEL 1: Method With Parameters (Inputs) and void Return
java
Copy
Edit
public class Printer {
    public void printName(String name) {
        System.out.println("Your name is: " + name);
    }

    public static void main(String[] args) {
        Printer p = new Printer();
        p.printName("Rahul");  // Output: Your name is: Rahul
    }
}


🚀 LEVEL 2: Method With Return Value
java
Copy
Edit
public class Adder {
    public int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        Adder obj = new Adder();
        int sum = obj.add(5, 7);
        System.out.println("Sum is: " + sum);  // Output: Sum is: 12
    }
}



🚀 LEVEL 3: Multiple Parameters, Multiple Methods
java
Copy
Edit
public class MathOperations {

    public int subtract(int a, int b) {
        return a - b;
    }

    public double divide(double x, double y) {
        return x / y;
    }

    public static void main(String[] args) {
        MathOperations m = new MathOperations();
        System.out.println("Subtract: " + m.subtract(10, 4));
        System.out.println("Divide: " + m.divide(20, 4));
    }
}



🚀 LEVEL 6: Method Overloading
java
Copy
Edit
public class OverloadExample {

    public int multiply(int a, int b) {
        return a * b;
    }

    public double multiply(double a, double b) {
        return a * b;
    }

    public static void main(String[] args) {
        OverloadExample obj = new OverloadExample();
        System.out.println(obj.multiply(2, 3));      // 6
        System.out.println(obj.multiply(2.5, 4.0));  // 10.0
    }
}



🔐 What is Encapsulation?
Encapsulation means wrapping data (variables) and code (methods) into a single unit, like a capsule 💊.
In Java, this is achieved by:

Making fields private

Giving public getter & setter methods to access/update them

🔸 Think of it like:
"Mobile ka internal system user se hidden hota hai, sirf buttons diye jaate hain control ke liye."

✅ Example of Encapsulation
java
Copy
Edit
public class Account {
    // Step 1: Make fields private
    private String name;
    private double balance;

    // Step 2: Create public getters and setters
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setBalance(double amount) {
        if (amount >= 0) {
            this.balance = amount;
        }
    }

    public double getBalance() {
        return balance;
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Account acc = new Account();

        acc.setName("Ravi");
        acc.setBalance(5000);

        System.out.println(acc.getName());     // Ravi
        System.out.println(acc.getBalance());  // 5000
    }
}
✅ Encapsulation protects data and gives you controlled access.




🔹 1. public: Accessible from anywhere
java
Copy
Edit
public class Car {
    public String brand = "Honda";
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Car c = new Car();
        System.out.println(c.brand);  // Accessible anywhere
    }
}
🔹 2. private: Accessible only inside the same class
java
Copy
Edit
public class Bank {
    private double balance = 1000;

    public double getBalance() {
        return balance;
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Bank b = new Bank();
        // System.out.println(b.balance); ❌ Error: private
        System.out.println(b.getBalance()); ✅ OK
    }
}
🔹 3. protected: Accessible in same package + subclass (even if in different package)
java
Copy
Edit
class Animal {
    protected String type = "Mammal";
}

class Dog extends Animal {
    public void printType() {
        System.out.println(type);  // ✅ Accessible
    }
}
🔹 4. Default (no modifier): Accessible only within the same package
java
Copy
Edit
class Phone {
    String model = "iPhone";  // Default access
}
java
Copy
Edit
// Accessible only if in same package
public class Main {
    public static void main(String[] args) {
        Phone p = new Phone();
        System.out.println(p.model);  // ✅ Only if in same package
    }
}



🧠 What are Getters and Setters?
🔹 Getters:
Ye methods field ki value read karne ke liye hote hain.

🔹 Setters:
Ye methods field ki value set/update karne ke liye hote hain.

❗ Generally fields private hote hain (Encapsulation), aur unke access ke liye public getter/setter diye jaate hain.

✅ Why Use Them Instead of Direct Access?
java
Copy
Edit
// ❌ NOT Recommended
public class Student {
    public String name;  // Direct access – bad practice
}
Isse data unsafe ho jata hai, koi bhi change kar sakta hai.

Instead, use private fields + get/set methods → ✅ Safe

✅ Example: Getters and Setters
java
Copy
Edit
public class Student {
    private String name;
    private int age;

    // Getter for name
    public String getName() {
        return name;
    }

    // Setter for name
    public void setName(String name) {
        this.name = name;
    }

    // Getter for age
    public int getAge() {
        return age;
    }

    // Setter for age
    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        }
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Student s = new Student();

        s.setName("Ravi");
        s.setAge(20);

        System.out.println("Name: " + s.getName());
        System.out.println("Age: " + s.getAge());
    }
}



🔹 1. Validation in Setter
java
Copy
Edit
public void setMarks(int marks) {
    if (marks >= 0 && marks <= 100) {
        this.marks = marks;
    } else {
        System.out.println("Invalid marks!");
    }
}
🔹 2. Read-only Field (Only Getter)
java
Copy
Edit
private final int id = 101;

public int getId() {
    return id;  // No setter → read-only
}
🔹 3. Write-only Field (Only Setter)
java
Copy
Edit
private String password;

public void setPassword(String password) {
    this.password = password;
}




🧠 What is Inheritance?
Inheritance means:
🔄 "Ek class (child) dusri class (parent) ke properties and methods ko inherit kar sakti hai".

In short:
🔸 Code reuse
🔸 Hierarchy (parent-child relationship)
🔸 Follows "is-a" relationship

✅ Syntax: extends Keyword
java
Copy
Edit
class Parent {
    // fields and methods
}

class Child extends Parent {
    // inherits everything from Parent
}
📌 extends ka matlab hota hai:
"Ye class us parent class ke saare methods aur variables inherit karegi."

🧾 Example: Basic Inheritance
java
Copy
Edit
// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Child class
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks.");
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();   // Inherited from Animal
        d.bark();  // Defined in Dog
    }
}




✅ Types of Inheritance in Java
Java supports Single, Multilevel, and Hierarchical Inheritance
❌ Java does not support Multiple Inheritance with classes (to avoid ambiguity), but you can achieve it with interfaces.

🔸 1. Single Inheritance
java
Copy
Edit
class A {
    void showA() { System.out.println("Class A"); }
}

class B extends A {
    void showB() { System.out.println("Class B"); }
}
🔸 2. Multilevel Inheritance
java
Copy
Edit
class A {
    void a() { System.out.println("A"); }
}

class B extends A {
    void b() { System.out.println("B"); }
}

class C extends B {
    void c() { System.out.println("C"); }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        C obj = new C();
        obj.a();  // from A
        obj.b();  // from B
        obj.c();  // from C
    }
}
🔸 3. Hierarchical Inheritance
java
Copy
Edit
class Animal {
    void eat() { System.out.println("eating..."); }
}

class Dog extends Animal {
    void bark() { System.out.println("barking..."); }
}

class Cat extends Animal {
    void meow() { System.out.println("meowing..."); }
}
❌ Why Java Doesn’t Support Multiple Inheritance with Classes
java
Copy
Edit
class A {
    void show() { System.out.println("A"); }
}

class B {
    void show() { System.out.println("B"); }
}

// class C extends A, B ❌ Not allowed – ambiguity
✔️ Java solves this using interfaces, not classes.

👨‍🏫 Why Java Doesn’t Support Multiple Inheritance (with classes)
🔴 Because it causes confusion called the "Diamond Problem"
🟡 Let’s Break It Down:
✅ First: What is Multiple Inheritance?
When a class inherits from more than one class, it’s called multiple inheritance.

🔧 Example in C++ (which allows multiple inheritance):
cpp
Copy
Edit
class A {
    void show();
};

class B {
    void show();
};

class C : public A, public B {
    // Inherits from both A and B
};
❓Problem: What if both A and B have the same method?
cpp
Copy
Edit
class A {
    void show() { cout << "A"; }
};

class B {
    void show() { cout << "B"; }
};

class C : public A, public B {
    // Which 'show()' will C use? A or B?
};
This creates ambiguity/confusion. This is called the diamond problem.


🧠 What is Inheritance?
Inheritance means:
🔄 "Ek class (child) dusri class (parent) ke properties and methods ko inherit kar sakti hai".

🧾 Example: Basic Inheritance
java
Copy
Edit
// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Child class
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks.");
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();   // Inherited from Animal
        d.bark();  // Defined in Dog
    }
}



🔄 What is Method Overriding?
Method Overriding means:
🔁 "Child class apne parent class ke method ko dubara define karta hai (same name, same parameters)"

✅ Overriding allows custom behavior in the child class.

📌 When Do We Use It?
Jab child class parent ka method inherit karta hai

But chahta hai ki apna version implement kare

✅ Rules of Method Overriding
Method name must be same

Parameters must be same (signature)

Must be inherited from parent class

Cannot override private, static, or final methods

Access modifier should be same or more visible

🔧 Syntax Example:
java
Copy
Edit
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();  // Polymorphism
        a.sound();  // Output: Dog barks
    }
}


 Explanation:
sound() method is defined in parent class Animal

Dog overrides that method to give custom behavior

✅ We use @Override annotation for clarity (optional, but recommended)



🔀 Super Keyword with Overriding
Use super.method() to call parent method inside overridden method.

java
Copy
Edit
class Parent {
    void greet() {
        System.out.println("Hello from Parent");
    }
}

class Child extends Parent {
    @Override
    void greet() {
        super.greet();  // calls parent version
        System.out.println("Hello from Child");
    }
}




✅ Advanced Example: Polymorphism with Overriding
java
Copy
Edit
class Shape {
    void draw() {
        System.out.println("Drawing shape");
    }
}

class Circle extends Shape {
    void draw() {
        System.out.println("Drawing circle");
    }
}

class Square extends Shape {
    void draw() {
        System.out.println("Drawing square");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape s;

        s = new Circle();
        s.draw(); // Drawing circle

        s = new Square();
        s.draw(); // Drawing square
    }
}



🔠 What is super keyword?
Java me super ka use child class se parent class ke members (variables, methods, constructor) ko refer karne ke liye hota hai.

🔹 Jab child aur parent class me same naam ke methods ya variables hote hain, tab super se parent version ko call kar sakte ho.

✅ Uses of super keyword:
Use Case	Example
1️⃣ Call parent class method	super.methodName()
2️⃣ Access parent class variable	super.variableName
3️⃣ Call parent constructor	super() (must be 1st line in constructor)



✅ 1. super.method() – Call parent method
java
Copy
Edit
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void sound() {
        super.sound();  // 🔹 Call parent method
        System.out.println("Dog barks");
    }
}
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
    }
}
Output:
Animal makes sound
Dog barks


✅ 2. super.variable – Access parent variable

class Parent {
    int x = 100;
}

class Child extends Parent {
    int x = 200;

    void show() {
        System.out.println("Child x: " + x);         // 200
        System.out.println("Parent x: " + super.x);  // 100
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Child c = new Child();
        c.show();
    }
}

✅ 3. super() – Call parent constructor
java
Copy
Edit
class Parent {
    Parent() {
        System.out.println("Parent constructor");
    }
}

class Child extends Parent {
    Child() {
        super(); // 🔹 Call to parent constructor
        System.out.println("Child constructor");
    }
}
java
Copy
Edit
public class Main {
    public static void main(String[] args) {
        Child c = new Child();
    }
}
🔍 Output:
kotlin
Copy
Edit
Parent constructor  
Child constructor

✅ super() always first line in child constructor.
Agar na likho, Java automatically call karta hai super() (default constructor).




🔶 What is Polymorphism?
Polymorphism means "many forms". In Java, it allows objects to take on many forms, specifically:

Compile-Time Polymorphism (Method Overloading)

Run-Time Polymorphism (Method Overriding)



✅ What is Method Overloading?
When multiple methods in the same class have the same name but different parameters (type or number), it's called method overloading.

📌 Example:
java
Copy
Edit
public class Calculator {
    // Adding two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Adding three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Adding two doubles
    public double add(double a, double b) {
        return a + b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(2, 3));           // 5
        System.out.println(calc.add(2, 3, 4));        // 9
        System.out.println(calc.add(2.5, 3.5));       // 6.0
    }
}
🔸 Part 2: Run-Time Polymorphism (Method Overriding)
✅ What is Method Overriding?
When a subclass provides its own implementation of a method defined in its superclass, it's called method overriding. This happens at runtime.

🧠 Key Conditions:
Method must have same name, return type, and parameters.

The class must use inheritance (extends).

Use @Override annotation (optional but recommended).

📌 Example:
java
Copy
Edit
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class TestPolymorphism {
    public static void main(String[] args) {
        Animal a;          // reference of superclass

        a = new Dog();     // Dog object
        a.sound();         // Dog barks

        a = new Cat();     // Cat object
        a.sound();         // Cat meows
    }
}
🔍 Output:
nginx
Copy
Edit
Dog barks
Cat meows
🔸 Part 3: Polymorphism with Interfaces
✅ Interface Polymorphism
Interfaces support polymorphism because a class can be referred to by its interface type.

📌 Example:
java
Copy
Edit
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Rectangle implements Shape {
    public void draw() {
        System.out.println("Drawing Rectangle");
    }
}

public class InterfacePolymorphism {
    public static void main(String[] args) {
        Shape s;

        s = new Circle();
        s.draw();  // Drawing Circle

        s = new Rectangle();
        s.draw();  // Drawing Rectangle
    }
}
🔸 Part 4: Advanced Polymorphism – Real-World Example
🧾 Example: Payment System
java
Copy
Edit
abstract class Payment {
    abstract void pay(double amount);
}

class CreditCard extends Payment {
    void pay(double amount) {
        System.out.println("Paid $" + amount + " using Credit Card.");
    }
}

class PayPal extends Payment {
    void pay(double amount) {
        System.out.println("Paid $" + amount + " using PayPal.");
    }
}

class Cash extends Payment {
    void pay(double amount) {
        System.out.println("Paid $" + amount + " in Cash.");
    }
}

public class PaymentProcessor {
    public static void processPayment(Payment p, double amount) {
        p.pay(amount); // Polymorphic call
    }

    public static void main(String[] args) {
        processPayment(new CreditCard(), 100.0);
        processPayment(new PayPal(), 250.0);
        processPayment(new Cash(), 50.0);
    }
}
🔸 Part 5: Polymorphism in Collections (Advanced Concept)
java
Copy
Edit
import java.util.ArrayList;

abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("Meow");
    }
}

public class Zoo {
    public static void main(String[] args) {
        ArrayList<Animal> animals = new ArrayList<>();
        animals.add(new Dog());
        animals.add(new Cat());

        for (Animal a : animals) {
            a.makeSound();  // Dynamic method dispatch
        }
    }
}




🔶 What is Abstraction?
Abstraction is one of the four pillars of Object-Oriented Programming (OOP), and it means hiding the internal implementation and showing only the necessary details to the user.

📦 Think of abstraction like using a TV remote:
You press buttons to change channels (interface), but you don't know how the circuit board inside works (implementation).

🔸 Why Use Abstraction?
To simplify complexity.

To hide implementation details.

To provide a blueprint for subclasses.

To enforce rules and contracts using abstract classes or interfaces.

🔸 How Abstraction is Achieved in Java
Java achieves abstraction in two ways:

Abstract Classes (Partial Abstraction)

Interfaces (Full Abstraction, before Java 8)

🔹 1. Abstract Classes
✅ Definition:
Declared using the abstract keyword.

Can have abstract (no body) and non-abstract (implemented) methods.

Cannot be instantiated directly.

📌 Basic Example:
java
Copy
Edit
abstract class Animal {
    abstract void sound();  // abstract method

    void sleep() {          // concrete method
        System.out.println("Animal is sleeping...");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class TestAbstraction {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.sound();  // Dog barks
        a.sleep();  // Animal is sleeping...
    }
}
🔐 Rules of Abstract Class
If a class has at least one abstract method, it must be declared abstract.

Subclasses must override all abstract methods, or they themselves become abstract.

 2. Interfaces
✅ Definition:
An interface is a contract for classes to follow.

Can only have abstract methods (until Java 7), and default/static methods (Java 8+).

A class implements an interface.

📌 Example:
java
Copy
Edit
interface Shape {
    void draw();  // abstract method
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Square implements Shape {
    public void draw() {
        System.out.println("Drawing Square");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        Shape s = new Circle();
        s.draw();  // Drawing Circle

        s = new Square();
        s.draw();  // Drawing Square
    }
}




🔶 What Are Static Members?
In Java, static members belong to the class rather than to instances (objects) of the class.

You can declare:

static variables (also called class variables)

static methods

static blocks




🔸 1. Static Variables (Class Variables)
A static variable is shared among all instances of a class. There's only one copy in memory.

📌 Example:
java
Copy
Edit
class Counter {
    static int count = 0;  // shared among all objects

    Counter() {
        count++;  // increments shared variable
        System.out.println("Count: " + count);
    }

    public static void main(String[] args) {
        new Counter();  // Count: 1
        new Counter();  // Count: 2
        new Counter();  // Count: 3
    }
}
🧠 Notice: All objects update the same count variable.

🔸 2. Static Methods
Static methods belong to the class, not the object. You can call them without creating an instance.

✅ Key Rules:
Can only access static data directly.

Cannot use this or super.

Often used for utility or helper methods.

📌 Example:
java
Copy
Edit
class MathUtils {
    static int square(int x) {
        return x * x;
    }

    public static void main(String[] args) {
        System.out.println(MathUtils.square(5));  // 25
    }
}
🔸 3. Static Block (Static Initializer)
Static blocks run once, when the class is first loaded into memory.

📌 Example:
java
Copy
Edit
class Demo {
    static {
        System.out.println("Static block executed.");
    }

    public static void main(String[] args) {
        System.out.println("Main method executed.");
    }
}
🔍 Output:
scss
Copy
Edit
Static block executed.
Main method executed.
🧠 Use static blocks to initialize static variables or perform setup logic before the main method.




🔶 What is a Package?
A package in Java is a namespace that groups related classes and interfaces together.

Think of it like folders on your computer:

📁 java.util → for utility classes

📁 java.io → for input/output classes

🔸 Why Use Packages?
✅ Avoid name conflicts
✅ Organize code better
✅ Control access (with access modifiers)
✅ Reusability and modularization

🔸 Types of Packages
1. Built-in Packages – Provided by Java
Examples:

java
Copy
Edit
import java.util.Scanner;
import java.io.File;
import java.lang.Math;  // automatically imported
2. User-defined Packages – Created by you
🔹 How to Create a User-defined Package
✅ Step-by-step:
1. Create a package
java
Copy
Edit
// File: MyPackage/Message.java
package MyPackage;

public class Message {
    public void show() {
        System.out.println("Hello from MyPackage!");
    }
}
2. Use the package
java
Copy
Edit
// File: Main.java
import MyPackage.Message;

public class Main {
    public static void main(String[] args) {
        Message m = new Message();
        m.show();
    }
}

import java.util.Scanner;          // Import a single class
import java.util.*;                // Import all classes in java.util
import static java.lang.Math.*;    // Static import (for static members)



🔶 What is Exception Handling?
An exception is an unexpected event that disrupts the normal flow of a program.

Exception Handling is Java’s mechanism to:

Detect errors

Handle them gracefully (without crashing)

Maintain program flow

🔸 Why Use Exception Handling?
✅ Prevent program from crashing
✅ Separate error-handling logic from main logic
✅ Handle runtime errors (like divide by zero, file not found)

🔶 Types of Exceptions
Java has two main types:

Type	Description	Example
Checked	Caught at compile time	IOException, SQLException
Unchecked	Caught at runtime	ArithmeticException, NullPointerException

🔶 Basic Syntax
java
Copy
Edit
try {
    // risky code
} catch (ExceptionType name) {
    // handling code
} finally {
    // optional block; always executes
}
🔸 📌 Example 1: Handling Divide by Zero
java
Copy
Edit
public class Divide {
    public static void main(String[] args) {
        try {
            int a = 10 / 0; // Risky
        } catch (ArithmeticException e) {
            System.out.println("Cannot divide by zero!");
        }
    }
}
🔍 Output:
csharp
Copy
Edit
Cannot divide by zero!
🔸 📌 Example 2: Multiple Catch Blocks
java
Copy
Edit
public class MultipleCatch {
    public static void main(String[] args) {
        try {
            int[] arr = new int[3];
            arr[5] = 10;  // ArrayIndexOutOfBoundsException
        } catch (ArithmeticException e) {
            System.out.println("Math error.");
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index error.");
        } catch (Exception e) {
            System.out.println("General error.");
        }
    }
}
Always catch specific exceptions first, then general ones.

🔸 📌 Example 3: The finally Block
java
Copy
Edit
public class FinallyBlock {
    public static void main(String[] args) {
        try {
            System.out.println("Inside try");
        } catch (Exception e) {
            System.out.println("Exception caught");
        } finally {
            System.out.println("This always runs!");
        }
    }
}
finally is used to close resources, like files or database connections.



🔸 📌 Example 4: throw Keyword
Manually throw an exception.

java
Copy
Edit
public class ThrowExample {
    public static void main(String[] args) {
        int age = 15;
        if (age < 18) {
            throw new ArithmeticException("Not eligible to vote");
        }
    }
}



🔸 📌 Example 5: throws Keyword
Tell the compiler that a method may throw an exception.

java
Copy
Edit
import java.io.*;

public class ThrowsExample {
    public static void readFile() throws IOException {
        FileReader fr = new FileReader("file.txt");
        fr.read();
    }

    public static void main(String[] args) throws IOException {
        readFile();  // caller is responsible
    }
}

🔶 What is Java Collections Framework?
The Java Collections Framework (JCF) is a set of classes and interfaces in java.util for storing, retrieving, and manipulating groups of data.

Think of it like Java's built-in toolbox for:

Lists 📋

Sets ✅

Maps 🗺️

Queues ⏳

Stacks 📚

1. List – Ordered, allows duplicates
Implementations: ArrayList, LinkedList, Vector, Stack

1️⃣ ArrayList – Most commonly used list
🔧 Internally:
Uses a resizable array

Fast for accessing elements (get(), set())

import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Java");
        list.add("Python");
        list.add("Java"); // duplicates allowed

        System.out.println(list); // [Java, Python, Java]
    }
}


2️⃣ LinkedList – Good for insertions/deletions
🔧 Internally:
Uses a doubly linked list

Nodes have reference to next and previous

import java.util.*;

public class LinkedListExample {
    public static void main(String[] args) {
        List<String> list = new LinkedList<>();
        list.add("Node1");
        list.add("Node2");
        list.add("Node3");

        System.out.println(list); // [Node1, Node2, Node3]
    }
}

✅ Best Use:
When you need to insert/delete a lot

Use as a queue or deque

3️⃣ Vector – Thread-safe ArrayList
🔧 Internally:
Like ArrayList but synchronized

import java.util.*;

public class VectorExample {
    public static void main(String[] args) {
        Vector<Integer> vec = new Vector<>();
        vec.add(1);
        vec.add(2);
        vec.add(3);

        System.out.println(vec); // [1, 2, 3]
    }
}


4️⃣ Stack – LIFO structure (Last-In, First-Out)
🔧 Internally:
Extends Vector

Has LIFO methods: push(), pop(), peek()

import java.util.*;

public class StackExample {
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>();
        stack.push("A");
        stack.push("B");
        stack.push("C");

        System.out.println(stack.pop()); // C
        System.out.println(stack.peek()); // B
    }
}



 What is a Set in Java?
Set is a collection that does not allow duplicate elements.
It’s part of the java.util package and extends the Collection interface.

🔍 When to use Set?
When you want unique values only (no duplicates)

When you don’t care about order → use HashSet

When you want insertion order → use LinkedHashSet

When you want sorted data → use TreeSet



1️⃣ HashSet
Uses hashing for storage

Unordered

Fast operations: add, remove, contains (O(1))

java
Copy
Edit
import java.util.*;

public class HashSetExample {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("Apple");
        set.add("Banana");
        set.add("Apple");  // duplicate

        System.out.println(set); // [Banana, Apple] (order not guaranteed)
    }
}
2️⃣ LinkedHashSet
Maintains insertion order

Still doesn’t allow duplicates

java
Copy
Edit
Set<String> set = new LinkedHashSet<>();
set.add("A");
set.add("B");
set.add("A"); // ignored

System.out.println(set); // [A, B]
3️⃣ TreeSet
Stores elements in sorted order (ascending by default)

Internally uses a Red-Black Tree

Does not allow null (throws exception)

java
Copy
Edit
Set<Integer> set = new TreeSet<>();
set.add(50);
set.add(10);
set.add(30);

System.out.println(set); // [10, 30, 50]
You can also sort custom objects using a Comparator.



🔹 What is a Map in Java?
A Map is a collection that stores data in the form of key-value pairs.

Each key is unique

Each key maps to one value

You can retrieve a value using its key



1️⃣ HashMap – Most commonly used Map
java
Copy
Edit
import java.util.*;

public class HashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();

        map.put("Apple", 2);
        map.put("Banana", 5);
        map.put("Apple", 4);  // overwrites previous value

        System.out.println(map); // {Banana=5, Apple=4}
    }
}
No order

Fast lookup and insertion (O(1))

One null key allowed

2️⃣ LinkedHashMap – Maintains insertion order
java
Copy
Edit
Map<String, Integer> map = new LinkedHashMap<>();
map.put("One", 1);
map.put("Two", 2);
map.put("Three", 3);

System.out.println(map); // {One=1, Two=2, Three=3}
Keeps the order you insert keys in

Good for predictable iteration

3️⃣ TreeMap – Sorted by key
java
Copy
Edit
Map<String, Integer> map = new TreeMap<>();
map.put("B", 20);
map.put("A", 10);
map.put("C", 30);

System.out.println(map); // {A=10, B=20, C=30}
Sorted by natural order of keys (String, Integer, etc.)

No null key allowed

4️⃣ Hashtable – Legacy, thread-safe version of HashMap
java
Copy
Edit
Map<String, String> map = new Hashtable<>();
map.put("username", "admin");
map.put("password", "1234");

System.out.println(map); // {username=admin, password=1234}
All methods synchronized

Slower than HashMap

❌ No null keys or null values






📦 Queue and Deque in Java
Both Queue and Deque are part of the Java Collection Framework and are used to store ordered elements, but they follow different insertion/removal rules.

1️⃣ Queue – First In, First Out (FIFO)
The element added first is removed first

Like a line at a ticket counter

🔑 Key Operations:
Method	Description
add()	Adds an element (throws exception if full)
offer()	Adds an element (returns false if full)
remove()	Removes the head (throws exception if empty)
poll()	Removes the head (returns null if empty)
peek()	Gets the head without removing it

🛠️ Common Implementations:
Class	Ordered?	Thread-safe?	Null Allowed?
LinkedList	✅ Yes	❌ No	✅
PriorityQueue	❌ Sorted by priority	❌ No	❌
ArrayDeque	✅ Yes	❌ No	❌

✅ Example: Queue using LinkedList
java
Copy
Edit
import java.util.*;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();

        queue.offer("A");
        queue.offer("B");
        queue.offer("C");

        System.out.println(queue.poll()); // A
        System.out.println(queue.peek()); // B
        System.out.println(queue);        // [B, C]
    }
}
2️⃣ Deque – Double-Ended Queue
You can add/remove from both ends

Think of it like a queue with 2 doors

🔑 Key Methods:
Method	From Front	From Rear
addFirst()	Inserts at front	
addLast()		Inserts at rear
removeFirst()	Removes from front	
removeLast()		Removes from rear
peekFirst()	View front	
peekLast()		View rear

✅ Example: Deque using ArrayDeque
java
Copy
Edit
import java.util.*;

public class DequeExample {
    public static void main(String[] args) {
        Deque<String> deque = new ArrayDeque<>();

        deque.addFirst("Front");
        deque.addLast("Rear");
        deque.addFirst("NewFront");

        System.out.println(deque); // [NewFront, Front, Rear]

        System.out.println(deque.removeLast()); // Rear
    }
}
🧠 Summary Table
Feature	Queue	Deque
Direction	One end (FIFO)	Both ends (LIFO & FIFO)
Insertion	Rear only	Front and Rear
Removal	Front only	Front and Rear
Common Uses	Printer queue, customer line	Undo/Redo, Palindrome checker

🔶 Important Methods (Collection Interface)
Method	Description
add(E e)	Add element
remove(Object o)	Remove element
contains(Object o)	Check if exists
isEmpty()	Is the collection empty?
size()	Total number of elements
clear()	Removes all elements
iterator()	Returns an Iterator

🔸 Iterating Over Collections
🔁 1. Enhanced for-loop
java
Copy
Edit
for (String name : names) {
    System.out.println(name);
}
🔁 2. Iterator
java
Copy
Edit
Iterator<String> it = names.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
🔸 Sorting Collections
java
Copy
Edit
List<String> cities = new ArrayList<>();
cities.add("Delhi");
cities.add("Mumbai");
cities.add("Chennai");

Collections.sort(cities);  // Sort alphabetically
✅ Use Collections.sort() or List.sort()

🔸 Advanced: Custom Sorting with Comparator
java
Copy
Edit
List<Integer> nums = Arrays.asList(5, 2, 8, 1);

Collections.sort(nums, (a, b) -> b - a);  // Descending order

System.out.println(nums);  // [8, 5, 2, 1]




Great! Let's dive into Wrapper Classes in Java — an essential topic when working with collections, parsing, and converting between primitive types and objects.

🔶 What Are Wrapper Classes?
In Java, wrapper classes are object representations of primitive data types.

Primitive Type	Wrapper Class
byte	Byte
short	Short
int	Integer
long	Long
float	Float
double	Double
char	Character
boolean	Boolean

🔸 Why Use Wrapper Classes?
✅ Needed when working with collections (ArrayList<int> is invalid; must use Integer)
✅ Provide utility methods (e.g., parsing, converting, comparing)
✅ Enable autoboxing and unboxing (automatic conversion between primitives and objects)

🔶 Autoboxing and Unboxing
🔁 Autoboxing – primitive → wrapper
java
Copy
Edit
int a = 10;
Integer obj = a;  // Automatically boxed
🔁 Unboxing – wrapper → primitive
java
Copy
Edit
Integer obj = 20;
int b = obj;      // Automatically unboxed
🔸 📌 Example: Using Wrapper with Collections
java
Copy
Edit
List<Integer> nums = new ArrayList<>();
nums.add(5);       // Autoboxed: int → Integer
int x = nums.get(0);  // Unboxed: Integer → int
🔶 Wrapper Class Methods
🔍 parseXXX(String s) – converts string to primitive
java
Copy
Edit
int x = Integer.parseInt("123");
double d = Double.parseDouble("3.14");
🔍 valueOf(String s) – converts string to wrapper object
java
Copy
Edit
Integer y = Integer.valueOf("123");
Boolean b = Boolean.valueOf("true");
🔍 toString() – converts value to string
java
Copy
Edit
int z = 42;
String s = Integer.toString(z);
🔶 Common Use Cases
✅ Parsing Input
java
Copy
Edit
String ageStr = "25";
int age = Integer.parseInt(ageStr);
✅ Converting to/from Strings
java
Copy
Edit
int number = 50;
String numStr = String.valueOf(number);  // "50"
✅ Working with Collections
java
Copy
Edit
ArrayList<Boolean> flags = new ArrayList<>();
flags.add(Boolean.TRUE);
🔶 Wrapper vs Primitive Summary
Feature	Primitive	Wrapper
Memory-efficient	✅	❌ (more overhead)
Can be null	❌	✅
Used in collections	❌	✅
Has methods	❌	✅

🔸 📌 Advanced: Comparing Wrapper Objects
java
Copy
Edit
Integer a = 1000;
Integer b = 1000;
System.out.println(a == b);        // false (different objects)
System.out.println(a.equals(b));   // true (values are equal)
⚠️ For values between -128 and 127, Java caches Integer objects — so == might return true.

🔶 Bonus: Converting Wrapper → Primitive → Wrapper
java
Copy
Edit
Double d = Double.valueOf(4.5);   // String to Wrapper
double val = d.doubleValue();     // Wrapper to primitive
Float f = (float) val;            // Primitive to another Wrapper
